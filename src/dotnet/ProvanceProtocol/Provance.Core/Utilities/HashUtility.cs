using Provance.Core.Data;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace Provance.Core.Utilities
{
    /// <summary>
    /// Provides static methods for deterministic SHA-256 hash calculation.
    /// This is the cryptographic core of the PROVANCE protocol.
    /// </summary>
    public static partial class HashUtility
    {
        // --- HEX REGEX UTILITY ---
        // HexRegex is initialized by calling the partial method MyRegex().
        // The implementation of MyRegex() is automatically generated by the [GeneratedRegex] attribute.
        // We use a property to lazily initialize the field using the generated method.
        private static Regex HexRegex => MyRegex();

        // Serialization options to ensure the JSON output is always the same,
        // regardless of execution or property order (determinism).
        private static readonly JsonSerializerOptions CanonicalOptions = new()
        {
            // IMPORTANT: Properties must be sorted alphabetically (default in .NET 8)
            // Indentation and comments must be disabled for consistency.
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
            WriteIndented = false
        };

        /// <summary>
        /// Calculates the HMAC-SHA256 signature of a <see cref="LedgerEntry"/> using a secret key.
        /// The signature is computed over a deterministic JSON representation of the entry that:
        /// excludes <c>CurrentHash</c>, includes <c>Sequence</c> to make ordering tamper-evident,
        /// and normalizes <c>PreviousHash</c> to lowercase for stable comparisons.
        /// </summary>
        /// <param name="entry">The ledger entry to sign.</param>
        /// <param name="secretKey">The secret key used for HMAC signing.</param>
        /// <returns>A lowercase hexadecimal HMAC-SHA256 signature.</returns>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="entry"/> is null.</exception>
        /// <exception cref="ArgumentException">Thrown when <paramref name="secretKey"/> is null or whitespace.</exception>
        public static string CalculateHash(LedgerEntry entry, string secretKey)
        {
            ArgumentNullException.ThrowIfNull(entry);
            ArgumentException.ThrowIfNullOrWhiteSpace(secretKey);

            // Do not include CurrentHash in the signed content.
            var entryToHash = new
            {
                // Include Sequence so ordering is tamper-evident.
                sequence = entry.Sequence,

                id = entry.Id,
                timestamp = entry.Timestamp,

                // Normalize to avoid case-related mismatches.
                previousHash = entry.PreviousHash?.ToLowerInvariant(),

                eventType = entry.EventType,
                payload = entry.Payload
            };

            string jsonString = JsonSerializer.Serialize(entryToHash, CanonicalOptions);

            byte[] hashBytes = ComputeHmacSha256(jsonString, secretKey);
            return Convert.ToHexString(hashBytes).ToLowerInvariant();
        }

        /// <summary>
        /// Calculates the HMAC-SHA256 hash from a data string using a secret key.
        /// </summary>
        private static byte[] ComputeHmacSha256(string data, string key)
        {
            byte[] keyBytes = Encoding.UTF8.GetBytes(key);
            byte[] dataBytes = Encoding.UTF8.GetBytes(data);

            using var hmac = new HMACSHA256(keyBytes);
            return hmac.ComputeHash(dataBytes);
        }

        /// <summary>
        /// Checks if a given string is composed purely of hexadecimal characters (0-9, a-f, A-F).
        /// </summary>
        /// <param name="hexString">The string to validate (e.g., a hash).</param>
        /// <returns>True if the string contains only hex characters; otherwise, false.</returns>
        public static bool IsValidHexString(string hexString)
        {
            if (string.IsNullOrEmpty(hexString))
            {
                return false;
            }
            return HexRegex.IsMatch(hexString);
        }

        /// <summary>
        /// This partial method's implementation is automatically generated by the C# compiler 
        /// using the [GeneratedRegex] attribute.
        /// </summary>
        [GeneratedRegex("^[0-9a-fA-F]*$", RegexOptions.Compiled)]
        private static partial Regex MyRegex();
    }
}