using Provance.Core.Data;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace Provance.Core.Utilities
{
    /// <summary>
    /// Provides static methods for deterministic SHA-256 hash calculation.
    /// This is the cryptographic core of the PROVANCE protocol.
    /// </summary>
    public static partial class HashUtility
    {
        // --- HEX REGEX UTILITY ---
        // HexRegex is initialized by calling the partial method MyRegex().
        // The implementation of MyRegex() is automatically generated by the [GeneratedRegex] attribute.
        // We use a property to lazily initialize the field using the generated method.
        private static Regex HexRegex => MyRegex();

        // Serialization options to ensure the JSON output is always the same,
        // regardless of execution or property order (determinism).
        private static readonly JsonSerializerOptions CanonicalOptions = new()
        {
            // IMPORTANT: Properties must be sorted alphabetically (default in .NET 8)
            // Indentation and comments must be disabled for consistency.
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
            WriteIndented = false
        };

        /// <summary>
        /// Calculates the SHA-256 hash of a LedgerEntry. 
        /// The hash is calculated on a canonical JSON representation of the entry.
        /// </summary>
        /// <param name="entry">The ledger entry to hash.</param>
        /// <returns>The SHA-256 hash string in hexadecimal format.</returns>
        public static string CalculateHash(LedgerEntry entry)
        {
            // 1. Create a temporary object that does NOT include CurrentHash
            // to ensure it is omitted from the calculated hash.
            var entryToHash = new
            {
                // Include all relevant properties in a deterministic order
                id = entry.Id,
                timestamp = entry.Timestamp,
                previousHash = entry.PreviousHash,
                eventType = entry.EventType,
                payload = entry.Payload
            };

            // 2. Serialize the object into deterministic JSON
            string jsonString = JsonSerializer.Serialize(entryToHash, CanonicalOptions);

            // 3. Calculate the SHA-256 hash
            byte[] hashBytes = ComputeSha256(jsonString);

            // 4. Convert hash bytes to hexadecimal string
            return BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
        }

        /// <summary>
        /// Calculates the SHA-256 hash from a data string.
        /// </summary>
        /// <param name="data">The data string to hash.</param>
        /// <returns>The hash as a byte array.</returns>
        private static byte[] ComputeSha256(string data)
        {
            byte[] inputBytes = Encoding.UTF8.GetBytes(data);
            return SHA256.HashData(inputBytes);
        }

        /// <summary>
        /// Checks if a given string is composed purely of hexadecimal characters (0-9, a-f, A-F).
        /// </summary>
        /// <param name="hexString">The string to validate (e.g., a hash).</param>
        /// <returns>True if the string contains only hex characters; otherwise, false.</returns>
        public static bool IsValidHexString(string hexString)
        {
            if (string.IsNullOrEmpty(hexString))
            {
                return false;
            }
            return HexRegex.IsMatch(hexString);
        }

        /// <summary>
        /// This partial method's implementation is automatically generated by the C# compiler 
        /// using the [GeneratedRegex] attribute.
        /// </summary>
        [GeneratedRegex("^[0-9a-fA-F]*$", RegexOptions.Compiled)]
        private static partial Regex MyRegex();
    }
}